<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Livecoding</title>

    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/tone"></script>

    <style>
        * {
            box-sizing: border-box;
        }

        body {
            background-color: #fafafa;
            color: #1a1a1a;
            font-family: 'Times New Roman', Times, serif;
            margin: 0;
            overflow: hidden;
        }

        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
            width: 100%;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 12px;
            width: 12px;
            border-radius: 50%;
            background: #1a1a1a;
            margin-top: -5px;
            cursor: pointer;
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 2px;
            cursor: pointer;
            background: #ccc;
        }

        select {
            font-family: 'Times New Roman', Times, serif;
        }

        button {
            font-family: 'Times New Roman', Times, serif;
        }

        ::selection {
            background: #1a1a1a;
            color: #fafafa;
        }
    </style>
</head>

<body>
    <div id="root" style="height: 100vh; width: 100vw; display: flex; flex-direction: column;"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;
        const apiKey = "";

        // Log errors to server
        const logErrorToServer = (message, stack, url, line, col) => {
            fetch('http://localhost:8080/log-error', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ message, stack, url, line, col })
            }).catch(() => { });
        };

        // Global error handler
        window.onerror = (message, url, line, col, error) => {
            logErrorToServer(message, error?.stack, url, line, col);
            return false;
        };

        // Unhandled promise rejection handler
        window.addEventListener('unhandledrejection', (event) => {
            logErrorToServer(
                event.reason?.message || String(event.reason),
                event.reason?.stack,
                window.location.href,
                null,
                null
            );
        });

        // --- TONE.JS EFFECT WRAPPERS ---
        // Tone.js effects use native Web Audio nodes (no worklets required)

        // --- EFFECT MANAGER ---
        class EffectManager {
            constructor(masterGain) {
                this.masterGain = masterGain;
                this.ctx = masterGain.context;
                this.effects = new Map(); // name -> { node, inputGain, type, lifetime, ticksRemaining, sends }
                this.pendingSends = []; // { sourceNode, effectName, amount } - for deferred connections
                this.defaultLifetime = 64; // ticks of inactivity before removal
                this.bpm = 120; // default BPM for tick-to-second conversion
            }

            setBpm(bpm) {
                this.bpm = bpm;
            }

            ticksToSeconds(ticks) {
                // 1 tick = (60 / bpm) / 4 seconds
                return ticks * (60.0 / this.bpm) / 4.0;
            }

            createEffect(type, params = {}) {
                // Factory for Tone.js effects (uses native Web Audio nodes, no worklets)
                // Clamp values to valid ranges
                const clamp01 = (val) => Math.max(0, Math.min(1, val));

                switch (type) {
                    case 'reverb':
                        // Tone.Reverb uses ConvolverNode (native)
                        // decay is in ticks, convert to seconds for roomSize calculation
                        const decaySeconds = params.decay !== undefined ? this.ticksToSeconds(params.decay) : 2.0;
                        const reverb = new Tone.Reverb({
                            roomSize: Math.min(0.99, decaySeconds / 10),
                            wet: clamp01(params.wet !== undefined ? params.wet : 0.5)
                        });
                        // Generate impulse response
                        reverb.generate();
                        return reverb;
                    case 'delay':
                        // Tone.FeedbackDelay uses DelayNode (native)
                        // delayTime is in ticks, convert to seconds
                        const delayTimeSeconds = params.delayTime !== undefined ? this.ticksToSeconds(params.delayTime) : this.ticksToSeconds(1);
                        // Clamp feedback to [0, 1] - values > 1 cause feedback explosion
                        return new Tone.FeedbackDelay({
                            delayTime: delayTimeSeconds,
                            feedback: clamp01(params.feedback !== undefined ? params.feedback : 0.5),
                            wet: clamp01(params.wet !== undefined ? params.wet : 0.5)
                        });
                    case 'pingpong':
                        // Tone.PingPongDelay alternates delayed signal between left and right channels
                        // delayTime is in ticks, convert to seconds
                        const pingpongDelayTimeSeconds = params.delayTime !== undefined ? this.ticksToSeconds(params.delayTime) : this.ticksToSeconds(1);
                        return new Tone.PingPongDelay({
                            delayTime: pingpongDelayTimeSeconds,
                            feedback: clamp01(params.feedback !== undefined ? params.feedback : 0.5),
                            wet: clamp01(params.wet !== undefined ? params.wet : 0.5)
                        });
                    case 'chorus':
                        // Tone.Chorus uses DelayNode with LFO (native)
                        return new Tone.Chorus({
                            frequency: params.frequency || 2,
                            delayTime: 0.01 + clamp01(params.depth || 0.5) * 0.01,
                            depth: clamp01(params.depth || 0.5),
                            wet: clamp01(params.wet !== undefined ? params.wet : 0.5)
                        });
                    case 'filter':
                        // Tone.Filter uses BiquadFilterNode (native)
                        return new Tone.Filter({
                            frequency: params.frequency || 1000,
                            type: params.filterType || params.type || 'lowpass',
                            Q: params.Q || 1
                        });
                    case 'distortion':
                        // Tone.Distortion uses WaveShaperNode (native)
                        return new Tone.Distortion({
                            distortion: clamp01(params.distortion !== undefined ? params.distortion : 0.4),
                            wet: clamp01(params.wet !== undefined ? params.wet : 0.5)
                        });
                    default:
                        console.warn(`Unknown effect type: ${type}`);
                        return null;
                }
            }

            updateEffect(name, params) {
                const existing = this.effects.get(name);

                if (existing) {
                    // Update parameters on existing effect
                    const node = existing.node;
                    this.applyParams(node, existing.type, params);

                    // Reset activity counter
                    existing.ticksRemaining = params.life || existing.lifetime;
                    existing.lifetime = params.life || existing.lifetime;

                    // Update sends if provided
                    if (params.sends) {
                        existing.sends = params.sends;
                        this.rewireEffectSends(name);
                    }
                } else if (params.type) {
                    // Create new effect
                    const node = this.createEffect(params.type, params);
                    if (!node) return;

                    // Create input gain for routing multiple sources
                    // All Tone.js effects are ToneAudioNodes
                    const inputGain = new Tone.Gain(1);
                    inputGain.connect(node);

                    const lifetime = params.life || this.defaultLifetime;
                    const effectData = {
                        node,
                        inputGain,
                        type: params.type,
                        lifetime,
                        ticksRemaining: lifetime,
                        sends: params.sends || null,
                        outputConnections: [] // Track outgoing connections
                    };

                    this.effects.set(name, effectData);

                    // Connect to master or other effects based on sends
                    if (params.sends) {
                        this.rewireEffectSends(name);
                    } else {
                        // Connect Tone.js effect to master
                        Tone.connect(node, this.masterGain);
                    }


                    // Process any pending sends waiting for this effect
                    this.processPendingSends(name);
                }
            }

            applyParams(node, type, params) {
                // Update Tone.js effect parameters
                // Clamp values to valid ranges
                const clamp01 = (val) => Math.max(0, Math.min(1, val));

                try {
                    switch (type) {
                        case 'reverb':
                            // Tone.Reverb params
                            // decay is in ticks, convert to seconds
                            if (params.decay !== undefined && node.roomSize) {
                                const decaySeconds = this.ticksToSeconds(params.decay);
                                node.roomSize.value = Math.min(0.99, decaySeconds / 10);
                                // Regenerate impulse response if decay changed significantly
                                if (node.generate) node.generate();
                            }
                            if (params.wet !== undefined && node.wet) {
                                node.wet.value = clamp01(params.wet);
                            }
                            break;
                        case 'delay':
                            // Tone.FeedbackDelay params
                            // delayTime is in ticks, convert to seconds
                            if (params.delayTime !== undefined && node.delayTime) {
                                node.delayTime.value = this.ticksToSeconds(params.delayTime);
                            }
                            if (params.feedback !== undefined && node.feedback) {
                                // Clamp feedback to [0, 1] to prevent feedback explosion
                                node.feedback.value = clamp01(params.feedback);
                            }
                            if (params.wet !== undefined && node.wet) {
                                node.wet.value = clamp01(params.wet);
                            }
                            break;
                        case 'pingpong':
                            // Tone.PingPongDelay params
                            // delayTime is in ticks, convert to seconds
                            if (params.delayTime !== undefined && node.delayTime) {
                                node.delayTime.value = this.ticksToSeconds(params.delayTime);
                            }
                            if (params.feedback !== undefined && node.feedback) {
                                // Clamp feedback to [0, 1] to prevent feedback explosion
                                node.feedback.value = clamp01(params.feedback);
                            }
                            if (params.wet !== undefined && node.wet) {
                                node.wet.value = clamp01(params.wet);
                            }
                            break;
                        case 'chorus':
                            // Tone.Chorus params
                            if (params.frequency !== undefined && node.frequency) {
                                node.frequency.value = params.frequency;
                            }
                            if (params.depth !== undefined) {
                                const clampedDepth = clamp01(params.depth);
                                if (node.depth) node.depth.value = clampedDepth;
                                if (node.delayTime) node.delayTime.value = 0.01 + clampedDepth * 0.01;
                            }
                            if (params.wet !== undefined && node.wet) {
                                node.wet.value = clamp01(params.wet);
                            }
                            break;
                        case 'filter':
                            // Tone.Filter params
                            if (params.frequency !== undefined && node.frequency) {
                                node.frequency.value = params.frequency;
                            }
                            if (params.Q !== undefined && node.Q) {
                                node.Q.value = params.Q;
                            }
                            if ((params.filterType !== undefined || params.type !== undefined) && node.type !== undefined) {
                                node.type = params.filterType || params.type;
                            }
                            break;
                        case 'distortion':
                            // Tone.Distortion params
                            if (params.distortion !== undefined && node.distortion) {
                                node.distortion.value = clamp01(params.distortion);
                            }
                            if (params.wet !== undefined && node.wet) {
                                node.wet.value = clamp01(params.wet);
                            }
                            break;
                    }
                } catch (e) {
                    console.warn('Error applying effect params:', e);
                }
            }

            rewireEffectSends(name) {
                const effectData = this.effects.get(name);
                if (!effectData || !effectData.sends) return;

                const node = effectData.node;

                // Disconnect existing outputs
                try {
                    node.disconnect();
                } catch (e) { }
                effectData.outputConnections = [];

                // Connect to target effects
                let hasConnection = false;
                for (const [targetName, amount] of Object.entries(effectData.sends)) {
                    const target = this.effects.get(targetName);
                    if (target) {
                        // Create a Tone.Gain for the send amount
                        const sendGain = new Tone.Gain(amount);

                        // Connect Tone.js effect to send gain to target input
                        Tone.connect(node, sendGain);
                        sendGain.connect(target.inputGain);

                        effectData.outputConnections.push({ target: targetName, gain: sendGain });
                        hasConnection = true;
                        // Mark target as active
                        target.ticksRemaining = target.lifetime;
                    }
                }

                // If no valid sends, connect to master
                if (!hasConnection) {
                    Tone.connect(node, this.masterGain);
                }
            }

            routeToEffect(effectName, sourceNode, amount) {
                const effectData = this.effects.get(effectName);

                if (effectData) {
                    try {
                        // Create Tone.Gain for send amount
                        const sendGain = new Tone.Gain(amount);

                        // Connect Web Audio source -> Tone.Gain -> Tone effect input
                        Tone.connect(sourceNode, sendGain);
                        sendGain.connect(effectData.inputGain);

                        // Reset activity counter
                        effectData.ticksRemaining = effectData.lifetime;

                        return sendGain;
                    } catch (e) {
                        console.warn(`Failed to route to effect ${effectName}:`, e);
                        return null;
                    }
                } else {
                    // Effect doesn't exist yet, queue for later
                    this.pendingSends.push({ sourceNode, effectName, amount });
                    return null;
                }
            }

            processPendingSends(effectName) {
                const remaining = [];
                for (const pending of this.pendingSends) {
                    if (pending.effectName === effectName) {
                        this.routeToEffect(effectName, pending.sourceNode, pending.amount);
                    } else {
                        remaining.push(pending);
                    }
                }
                this.pendingSends = remaining;
            }

            tick() {
                // Called each tick to manage effect lifetimes
                const toRemove = [];

                for (const [name, effectData] of this.effects) {
                    effectData.ticksRemaining--;

                    if (effectData.ticksRemaining <= 0) {
                        toRemove.push(name);
                    }
                }

                // Remove inactive effects
                for (const name of toRemove) {
                    this.removeEffect(name);
                }
            }

            markActive(effectName) {
                const effectData = this.effects.get(effectName);
                if (effectData) {
                    effectData.ticksRemaining = effectData.lifetime;
                }
            }

            removeEffect(name) {
                const effectData = this.effects.get(name);
                if (effectData) {
                    try {
                        // Disconnect and dispose Tone.js node
                        effectData.node.disconnect();
                        effectData.node.dispose();

                        // Disconnect and dispose input gain
                        effectData.inputGain.disconnect();
                        effectData.inputGain.dispose();

                        // Clean up output connections
                        for (const conn of effectData.outputConnections) {
                            try {
                                conn.gain.disconnect();
                                conn.gain.dispose();
                            } catch (e) { }
                        }
                    } catch (e) { }
                    this.effects.delete(name);
                    console.log(`Effect removed: ${name}`);
                }
            }

            clear() {
                for (const name of this.effects.keys()) {
                    this.removeEffect(name);
                }
                this.pendingSends = [];
            }

            getEffect(name) {
                return this.effects.get(name);
            }

            hasEffect(name) {
                return this.effects.has(name);
            }
        }

        // --- AUDIO ENGINE ---
        class AudioEngine {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();

                // Sync Tone.js context with our AudioContext
                Tone.setContext(this.ctx);

                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.3;
                this.masterGain.connect(this.ctx.destination);

                // Legacy reverb for backwards compatibility (r parameter)
                this.reverbNode = this.ctx.createConvolver();
                this.reverbNode.buffer = this.createReverbBuffer(2.0);
                this.reverbGain = this.ctx.createGain();
                this.reverbGain.gain.value = 0.4;
                this.reverbNode.connect(this.reverbGain);
                this.reverbGain.connect(this.masterGain);

                // Effect manager for send system
                this.effectManager = new EffectManager(this.masterGain);
                this.bpm = 120; // default BPM

                this.noiseBuffer = this.createNoiseBuffer();
                this.midiAccess = null;
                this.midiOutputs = [];
                this.selectedMidiOutput = null;
                this.onMidiOutputsChange = null;
                this.initMidi();

                this.sampleCache = {};
                this.searchCache = {};
                this.activeNotes = {};
                this.activeMidiNotes = {}; // Track MIDI notes by ID: { id: { channel, pitch, offTimeout } }

                // Note event callback for visualization
                this.onNoteEvent = null;
            }

            stopNoteById(id) {
                const active = this.activeNotes[id];
                if (active) {
                    try {
                        active.gain.gain.setTargetAtTime(0, this.ctx.currentTime, 0.01);
                        if (active.source && active.source.stop) {
                            active.source.stop(this.ctx.currentTime + 0.05);
                        }
                    } catch (e) { }
                    delete this.activeNotes[id];
                }
            }

            stopMidiNoteById(id) {
                const active = this.activeMidiNotes[id];
                if (active) {
                    clearTimeout(active.offTimeout);
                    const output = this.midiAccess?.outputs.get(this.selectedMidiOutput);
                    if (output) {
                        const noteOff = 0x80 | active.channel;
                        try { output.send([noteOff, active.pitch, 0]); } catch (e) { }
                    }
                    delete this.activeMidiNotes[id];
                }
            }

            registerNote(id, gain, source) {
                if (id !== undefined && id !== null) {
                    this.stopNoteById(id);
                    this.activeNotes[id] = { gain, source };
                }
            }

            parseBooleanSearch(query) {
                const tokens = [];
                let current = '';

                for (let i = 0; i < query.length; i++) {
                    const char = query[i];
                    const nextChar = i + 1 < query.length ? query[i + 1] : '';

                    if (char === '|' && nextChar === '|') {
                        if (current.trim()) {
                            tokens.push(current.trim());
                            current = '';
                        }
                        tokens.push('||');
                        i++;
                    } else if (char === '&') {
                        if (current.trim()) {
                            tokens.push(current.trim());
                            current = '';
                        }
                        tokens.push('&');
                    } else if (char === '(') {
                        if (current.trim()) {
                            tokens.push(current.trim());
                            current = '';
                        }
                        tokens.push('(');
                    } else if (char === ')') {
                        if (current.trim()) {
                            tokens.push(current.trim());
                            current = '';
                        }
                        tokens.push(')');
                    } else if (char === ' ') {
                        if (current.trim()) {
                            tokens.push(current.trim());
                            current = '';
                        }
                    } else {
                        current += char;
                    }
                }
                if (current.trim()) tokens.push(current.trim());

                const output = [];
                const operators = [];
                const precedence = { '||': 1, '&': 2 };

                for (const token of tokens) {
                    if (token === '&' || token === '||') {
                        while (operators.length > 0) {
                            const top = operators[operators.length - 1];
                            if (top === '(' || precedence[top] < precedence[token]) break;
                            output.push(operators.pop());
                        }
                        operators.push(token);
                    } else if (token === '(') {
                        operators.push(token);
                    } else if (token === ')') {
                        while (operators.length > 0 && operators[operators.length - 1] !== '(') {
                            output.push(operators.pop());
                        }
                        operators.pop();
                    } else {
                        output.push(token);
                    }
                }
                while (operators.length > 0) {
                    output.push(operators.pop());
                }

                return output;
            }

            async evaluateBooleanSearch(postfix) {
                const uniqueTerms = new Set();
                for (const token of postfix) {
                    if (token !== '&' && token !== '||') {
                        uniqueTerms.add(token);
                    }
                }

                const termResults = {};
                for (const term of uniqueTerms) {
                    if (!this.searchCache[term]) {
                        const res = await fetch(`http://localhost:8080/search?q=${encodeURIComponent(term)}`);
                        this.searchCache[term] = await res.json();
                    }
                    termResults[term] = this.searchCache[term];
                }

                const stack = [];
                for (const token of postfix) {
                    if (token === '&') {
                        const right = stack.pop();
                        const left = stack.pop();
                        const intersection = left.filter(l =>
                            right.some(r => r.path === l.path)
                        );
                        stack.push(intersection);
                    } else if (token === '||') {
                        const right = stack.pop();
                        const left = stack.pop();
                        const union = [...left];
                        for (const r of right) {
                            if (!union.some(u => u.path === r.path)) {
                                union.push(r);
                            }
                        }
                        stack.push(union);
                    } else {
                        stack.push(termResults[token] || []);
                    }
                }

                return stack.length > 0 ? stack[0] : [];
            }

            async loadSample(query, index) {
                const key = `${query}:${index}`;
                if (this.sampleCache[key]) return this.sampleCache[key].buffer;

                this.sampleCache[key] = { buffer: null, loading: true };

                try {
                    let results;

                    if (query.includes('&') || query.includes('||') || query.includes('(')) {
                        const postfix = this.parseBooleanSearch(query);
                        results = await this.evaluateBooleanSearch(postfix);
                        this.searchCache[query] = results;
                    } else {
                        if (!this.searchCache[query]) {
                            const res = await fetch(`http://localhost:8080/search?q=${encodeURIComponent(query)}`);
                            this.searchCache[query] = await res.json();
                        }
                        results = this.searchCache[query];
                    }

                    if (results.length === 0) {
                        console.warn(`Sample ${key}: no results found`);
                        this.sampleCache[key].loading = false;
                        return null;
                    }

                    const wrappedIndex = index % results.length;

                    const sampleInfo = results[wrappedIndex];
                    const audioRes = await fetch(`http://localhost:8080/sample?path=${encodeURIComponent(sampleInfo.path)}`);
                    const arrayBuffer = await audioRes.arrayBuffer();
                    const audioBuffer = await this.ctx.decodeAudioData(arrayBuffer);

                    this.sampleCache[key].buffer = audioBuffer;
                    this.sampleCache[key].loading = false;
                    console.log(`Loaded sample [${wrappedIndex}/${results.length}]: ${sampleInfo.name}`);
                    return audioBuffer;
                } catch (e) {
                    console.error(`Failed to load sample ${key}:`, e);
                    this.sampleCache[key].loading = false;
                    return null;
                }
            }

            playSample(buffer, time, vol, pan, reverbAmount, pitch = 60) {
                const source = this.ctx.createBufferSource();
                source.buffer = buffer;
                source.playbackRate.value = Math.pow(2, (pitch - 60) / 12);
                const gain = this.ctx.createGain();
                const panner = this.ctx.createStereoPanner();
                const revSend = this.ctx.createGain();

                source.connect(gain);
                gain.connect(panner);
                panner.connect(this.masterGain);
                panner.connect(revSend);
                revSend.connect(this.reverbNode);

                panner.pan.value = pan;
                revSend.gain.value = reverbAmount;
                gain.gain.value = vol;

                source.start(time);
                source.onended = () => { try { gain.disconnect(); panner.disconnect(); revSend.disconnect(); } catch (e) { } };
            }

            async initMidi() {
                if (navigator.requestMIDIAccess) {
                    try {
                        this.midiAccess = await navigator.requestMIDIAccess();
                        this.refreshMidiOutputs();
                        this.midiAccess.onstatechange = () => this.refreshMidiOutputs();
                    } catch (e) { console.warn("MIDI Fail", e); }
                }
            }

            refreshMidiOutputs() {
                this.midiOutputs = [];
                if (this.midiAccess) {
                    for (let output of this.midiAccess.outputs.values()) {
                        this.midiOutputs.push({ id: output.id, name: output.name });
                    }
                }
                if (this.midiOutputs.length > 0) {
                    const currentExists = this.midiOutputs.some(o => o.id === this.selectedMidiOutput);
                    if (!currentExists) {
                        this.selectedMidiOutput = this.midiOutputs[0].id;
                    }
                } else {
                    this.selectedMidiOutput = null;
                }
                if (this.onMidiOutputsChange) this.onMidiOutputsChange();
            }

            setMidiOutput(id) {
                this.selectedMidiOutput = id;
            }

            getMidiOutputs() {
                return this.midiOutputs;
            }

            getSelectedMidiOutput() {
                return this.selectedMidiOutput;
            }

            setVolume(val) {
                this.masterGain.gain.setTargetAtTime(val, this.ctx.currentTime, 0.1);
            }

            setBpm(bpm) {
                this.bpm = bpm;
                this.effectManager.setBpm(bpm);
            }

            createNoiseBuffer() {
                const bufferSize = this.ctx.sampleRate * 2;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                return buffer;
            }

            createReverbBuffer(duration) {
                const sampleRate = this.ctx.sampleRate;
                const length = sampleRate * duration;
                const impulse = this.ctx.createBuffer(2, length, sampleRate);
                const left = impulse.getChannelData(0);
                const right = impulse.getChannelData(1);
                for (let i = 0; i < length; i++) {
                    const decay = Math.pow(1 - i / length, 2);
                    left[i] = (Math.random() * 2 - 1) * decay;
                    right[i] = (Math.random() * 2 - 1) * decay;
                }
                return impulse;
            }

            resume() {
                if (this.ctx.state === 'suspended') this.ctx.resume();
            }

            midiToFreq(m) {
                return 440 * Math.pow(2, (m - 69) / 12);
            }

            triggerKick(time, vol, pan, reverbAmount, sends = null) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const panner = this.ctx.createStereoPanner();
                const revSend = this.ctx.createGain();

                osc.connect(gain); gain.connect(panner); panner.connect(this.masterGain);
                panner.connect(revSend); revSend.connect(this.reverbNode);

                // Effect sends
                const sendGains = [];
                if (sends) {
                    for (const [effectName, amount] of Object.entries(sends)) {
                        const sendGain = this.effectManager.routeToEffect(effectName, panner, amount);
                        if (sendGain) sendGains.push(sendGain);
                    }
                }

                panner.pan.value = pan; revSend.gain.value = reverbAmount;
                osc.frequency.setValueAtTime(150, time);
                osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
                gain.gain.setValueAtTime(vol, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
                osc.start(time); osc.stop(time + 0.5);
                osc.onended = () => { try { gain.disconnect(); panner.disconnect(); revSend.disconnect(); sendGains.forEach(sg => { try { sg.dispose(); } catch (e) { } }); } catch (e) { } };
            }

            triggerSnare(time, vol, pan, reverbAmount, sends = null) {
                const noise = this.ctx.createBufferSource(); noise.buffer = this.noiseBuffer;
                const noiseFilter = this.ctx.createBiquadFilter(); noiseFilter.type = 'highpass'; noiseFilter.frequency.value = 1000;
                const noiseGain = this.ctx.createGain();
                noise.connect(noiseFilter); noiseFilter.connect(noiseGain);

                const osc = this.ctx.createOscillator(); osc.type = 'triangle';
                const oscGain = this.ctx.createGain(); osc.connect(oscGain);

                const panner = this.ctx.createStereoPanner(); const revSend = this.ctx.createGain();
                noiseGain.connect(panner); oscGain.connect(panner);
                panner.connect(this.masterGain); panner.connect(revSend); revSend.connect(this.reverbNode);

                // Effect sends
                const sendGains = [];
                if (sends) {
                    for (const [effectName, amount] of Object.entries(sends)) {
                        const sendGain = this.effectManager.routeToEffect(effectName, panner, amount);
                        if (sendGain) sendGains.push(sendGain);
                    }
                }

                panner.pan.value = pan; revSend.gain.value = reverbAmount;
                noiseGain.gain.setValueAtTime(vol, time); noiseGain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
                osc.frequency.setValueAtTime(100, time); oscGain.gain.setValueAtTime(vol * 0.5, time); oscGain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);

                noise.start(time); osc.start(time);
                noise.stop(time + 0.2); osc.stop(time + 0.2);
                osc.onended = () => { try { panner.disconnect(); revSend.disconnect(); noiseGain.disconnect(); oscGain.disconnect(); sendGains.forEach(sg => { try { sg.dispose(); } catch (e) { } }); } catch (e) { } };
            }

            triggerHiHat(time, vol, pan, reverbAmount, open = false, sends = null) {
                const source = this.ctx.createBufferSource(); source.buffer = this.noiseBuffer;
                const filter = this.ctx.createBiquadFilter(); filter.type = 'highpass'; filter.frequency.value = 7000;
                const gain = this.ctx.createGain();
                const panner = this.ctx.createStereoPanner(); const revSend = this.ctx.createGain();

                source.connect(filter); filter.connect(gain); gain.connect(panner);
                panner.connect(this.masterGain); panner.connect(revSend); revSend.connect(this.reverbNode);

                // Effect sends
                const sendGains = [];
                if (sends) {
                    for (const [effectName, amount] of Object.entries(sends)) {
                        const sendGain = this.effectManager.routeToEffect(effectName, panner, amount);
                        if (sendGain) sendGains.push(sendGain);
                    }
                }

                panner.pan.value = pan; revSend.gain.value = reverbAmount;
                const duration = open ? 0.3 : 0.05;
                gain.gain.setValueAtTime(vol * 0.8, time); gain.gain.exponentialRampToValueAtTime(0.01, time + duration);
                source.start(time); source.stop(time + duration + 0.05);
                source.onended = () => { try { panner.disconnect(); gain.disconnect(); revSend.disconnect(); sendGains.forEach(sg => { try { sg.dispose(); } catch (e) { } }); } catch (e) { } };
            }

            triggerClap(time, vol, pan, reverbAmount, sends = null) {
                const source = this.ctx.createBufferSource(); source.buffer = this.noiseBuffer;
                const filter = this.ctx.createBiquadFilter(); filter.type = 'bandpass'; filter.frequency.value = 1500; filter.Q.value = 1;
                const gain = this.ctx.createGain();
                const panner = this.ctx.createStereoPanner(); const revSend = this.ctx.createGain();

                source.connect(filter); filter.connect(gain); gain.connect(panner);
                panner.connect(this.masterGain); panner.connect(revSend); revSend.connect(this.reverbNode);

                // Effect sends
                const sendGains = [];
                if (sends) {
                    for (const [effectName, amount] of Object.entries(sends)) {
                        const sendGain = this.effectManager.routeToEffect(effectName, panner, amount);
                        if (sendGain) sendGains.push(sendGain);
                    }
                }

                panner.pan.value = pan; revSend.gain.value = reverbAmount;
                const t = time;
                gain.gain.setValueAtTime(0, t); gain.gain.linearRampToValueAtTime(vol, t + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.1, t + 0.02); gain.gain.linearRampToValueAtTime(vol, t + 0.03);
                gain.gain.exponentialRampToValueAtTime(0.1, t + 0.04); gain.gain.linearRampToValueAtTime(vol, t + 0.05);
                gain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
                source.start(time); source.stop(time + 0.25);
                source.onended = () => { try { panner.disconnect(); gain.disconnect(); revSend.disconnect(); sendGains.forEach(sg => { try { sg.dispose(); } catch (e) { } }); } catch (e) { } };
            }

            triggerTom(time, vol, pan, reverbAmount, pitch = 100, sends = null) {
                const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                const panner = this.ctx.createStereoPanner(); const revSend = this.ctx.createGain();
                osc.connect(gain); gain.connect(panner); panner.connect(this.masterGain);
                panner.connect(revSend); revSend.connect(this.reverbNode);

                // Effect sends
                const sendGains = [];
                if (sends) {
                    for (const [effectName, amount] of Object.entries(sends)) {
                        const sendGain = this.effectManager.routeToEffect(effectName, panner, amount);
                        if (sendGain) sendGains.push(sendGain);
                    }
                }

                panner.pan.value = pan; revSend.gain.value = reverbAmount;
                osc.frequency.setValueAtTime(pitch, time); osc.frequency.exponentialRampToValueAtTime(pitch * 0.5, time + 0.2);
                gain.gain.setValueAtTime(vol, time); gain.gain.exponentialRampToValueAtTime(0.001, time + 0.2);
                osc.start(time); osc.stop(time + 0.25);
                osc.onended = () => { try { panner.disconnect(); gain.disconnect(); revSend.disconnect(); sendGains.forEach(sg => { try { sg.dispose(); } catch (e) { } }); } catch (e) { } };
            }

            triggerMidi(channel, pitch, vol, duration, audioTime, noteId) {
                if (!this.midiAccess || !this.selectedMidiOutput) return;
                const output = this.midiAccess.outputs.get(this.selectedMidiOutput);
                if (!output) return;

                // If this note has an ID, cancel any previous note with same ID
                if (noteId !== undefined) {
                    this.stopMidiNoteById(noteId);
                }

                const velocity = Math.min(127, Math.max(0, Math.floor(vol * 127)));
                const noteOn = 0x90 | channel;
                const noteOff = 0x80 | channel;
                const nowAudio = this.ctx.currentTime;
                const nowPerf = performance.now();
                const timeOffset = (audioTime - nowAudio) * 1000;
                const timestamp = nowPerf + Math.max(0, timeOffset);
                try {
                    output.send([noteOn, pitch, velocity], timestamp);

                    // Schedule note-off and track by ID
                    const offTimeout = setTimeout(() => {
                        try { output.send([noteOff, pitch, 0]); } catch (e) { }
                        if (noteId !== undefined) delete this.activeMidiNotes[noteId];
                    }, Math.max(0, timeOffset) + (duration * 1000));

                    if (noteId !== undefined) {
                        this.activeMidiNotes[noteId] = { channel, pitch, offTimeout };
                    }
                } catch (e) { console.error('MIDI send error', e); }
            }

            playNote(midi, time, durationSeconds, options = {}) {
                const vol = options.vol !== undefined ? options.vol : 0.5;
                const pan = options.pan !== undefined ? options.pan : 0;
                const reverbAmount = options.reverb !== undefined ? options.reverb : 0.0;
                const sends = options.sends || null;
                const noteId = options.id;
                let wave = options.wave || 'sine';

                if (noteId !== undefined) {
                    this.stopNoteById(noteId);
                }

                // Emit note event for visualization
                if (this.onNoteEvent) {
                    this.onNoteEvent({
                        pitch: midi,
                        velocity: vol,
                        wave: wave,
                        duration: durationSeconds,
                        time: time
                    });
                }

                if (typeof wave === 'string' && wave.startsWith('m:')) {
                    const chStr = wave.split(':')[1];
                    let ch = parseInt(chStr); if (isNaN(ch)) ch = 1;
                    const midiCh = (ch - 1) & 0x0F;
                    this.triggerMidi(midiCh, midi, vol, durationSeconds, time, noteId);
                    return;
                }

                if (wave === 'drums') {
                    if (midi === 36 || midi === 35) this.triggerKick(time, vol, pan, reverbAmount, sends);
                    else if (midi === 38 || midi === 40) this.triggerSnare(time, vol, pan, reverbAmount, sends);
                    else if (midi === 39) this.triggerClap(time, vol, pan, reverbAmount, sends);
                    else if (midi === 42 || midi === 44) this.triggerHiHat(time, vol, pan, reverbAmount, false, sends);
                    else if (midi === 46) this.triggerHiHat(time, vol, pan, reverbAmount, true, sends);
                    else if (midi === 41 || midi === 43 || midi === 45 || midi === 47 || midi === 48 || midi === 50) {
                        let pitch = 80; if (midi > 43) pitch = 110; if (midi > 47) pitch = 140;
                        this.triggerTom(time, vol, pan, reverbAmount, pitch, sends);
                    }
                    else this.triggerTom(time, vol, pan, reverbAmount, 300, sends);
                    return;
                }

                const sampleMatch = wave.match(/^([^:]+):(\d+)$/);
                if (sampleMatch) {
                    const query = sampleMatch[1];
                    const index = parseInt(sampleMatch[2]);
                    const key = `${query}:${index}`;
                    const cached = this.sampleCache[key];
                    if (cached && cached.buffer) {
                        const attack = options.attack !== undefined ? options.attack : 0.01;
                        this.playSampleWithId(cached.buffer, time, vol, pan, reverbAmount, midi, noteId, durationSeconds, options.start, sends, attack);
                    } else if (!cached || !cached.loading) {
                        this.loadSample(query, index);
                    }
                    return;
                }

                const cutoff = options.cutoff !== undefined ? options.cutoff : 2000;
                const attack = options.attack !== undefined ? options.attack : 0.01;
                const decay = options.decay !== undefined ? options.decay : 0.1;
                const fmIndex = options.fm || 0;

                const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                const panner = this.ctx.createStereoPanner(); const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass'; filter.Q.value = options.Q || 1;
                filter.frequency.setValueAtTime(cutoff, time); filter.frequency.exponentialRampToValueAtTime(Math.max(100, cutoff * 0.1), time + durationSeconds);

                const freq = this.midiToFreq(midi); osc.frequency.setValueAtTime(freq, time);
                const modulator = this.ctx.createOscillator(); const modGain = this.ctx.createGain();
                osc.type = wave; modulator.type = 'square'; modulator.frequency.value = freq * (options.ratio || 2);
                modGain.gain.value = fmIndex * 100;

                if (fmIndex > 0) { modulator.connect(modGain); modGain.connect(osc.frequency); }
                osc.connect(filter); filter.connect(gain); gain.connect(panner);
                panner.connect(this.masterGain);

                // Legacy reverb (r parameter) - backwards compatible
                const revSend = this.ctx.createGain();
                revSend.gain.value = Math.max(0, Math.min(1, reverbAmount));
                panner.connect(revSend);
                revSend.connect(this.reverbNode);

                // New send system
                const sendGains = [];
                if (sends) {
                    for (const [effectName, amount] of Object.entries(sends)) {
                        const sendGain = this.effectManager.routeToEffect(effectName, panner, amount);
                        if (sendGain) sendGains.push(sendGain);
                    }
                }

                panner.pan.value = pan;
                gain.gain.setValueAtTime(0, time);
                gain.gain.linearRampToValueAtTime(vol, time + Math.max(0.001, attack));
                gain.gain.exponentialRampToValueAtTime(0.001, time + durationSeconds + attack + decay);

                osc.start(time); if (fmIndex > 0) modulator.start(time);
                const stopTime = time + durationSeconds + attack + decay + 0.2;
                osc.stop(stopTime); if (fmIndex > 0) modulator.stop(stopTime);

                if (noteId !== undefined) {
                    this.activeNotes[noteId] = { gain, source: osc };
                }

                osc.onended = () => {
                    try {
                        gain.disconnect();
                        panner.disconnect();
                        revSend.disconnect();
                        sendGains.forEach(sg => { try { sg.dispose(); } catch (e) { } });
                    } catch (e) { }
                    if (noteId !== undefined && this.activeNotes[noteId]?.source === osc) {
                        delete this.activeNotes[noteId];
                    }
                };
            }

            playSampleWithId(buffer, time, vol, pan, reverbAmount, pitch, noteId, requestedDuration, startPos, sends = null, attack = 0.01) {
                const source = this.ctx.createBufferSource();
                source.buffer = buffer;
                source.playbackRate.value = Math.pow(2, (pitch - 60) / 12);
                const gain = this.ctx.createGain();
                const panner = this.ctx.createStereoPanner();
                const revSend = this.ctx.createGain();

                source.connect(gain);
                gain.connect(panner);
                panner.connect(this.masterGain);
                panner.connect(revSend);
                revSend.connect(this.reverbNode);

                // Effect sends
                const sendGains = [];
                if (sends) {
                    for (const [effectName, amount] of Object.entries(sends)) {
                        const sendGain = this.effectManager.routeToEffect(effectName, panner, amount);
                        if (sendGain) sendGains.push(sendGain);
                    }
                }

                panner.pan.value = pan;
                revSend.gain.value = reverbAmount;

                const offsetSeconds = (startPos || 0) * buffer.duration;
                const remainingDuration = (buffer.duration - offsetSeconds) / source.playbackRate.value;
                const fadeTime = 0.1;

                if (requestedDuration && requestedDuration < remainingDuration) {
                    gain.gain.setValueAtTime(0, time);
                    gain.gain.linearRampToValueAtTime(vol, time + Math.max(0.001, attack));
                    gain.gain.setValueAtTime(vol, time + requestedDuration - fadeTime);
                    gain.gain.linearRampToValueAtTime(0, time + requestedDuration);
                    source.start(time, offsetSeconds, requestedDuration * source.playbackRate.value);
                } else {
                    gain.gain.setValueAtTime(0, time);
                    gain.gain.linearRampToValueAtTime(vol, time + Math.max(0.001, attack));
                    source.start(time, offsetSeconds);
                }

                if (noteId !== undefined) {
                    this.activeNotes[noteId] = { gain, source };
                }

                source.onended = () => {
                    try { gain.disconnect(); panner.disconnect(); revSend.disconnect(); sendGains.forEach(sg => { try { sg.dispose(); } catch (e) { } }); } catch (e) { }
                    if (noteId !== undefined && this.activeNotes[noteId]?.source === source) {
                        delete this.activeNotes[noteId];
                    }
                };
            }

            // Process effect events
            processEffectEvent(event, bpm) {
                if (event.effect) {
                    // Update BPM if provided
                    if (bpm !== undefined) {
                        this.setBpm(bpm);
                    }
                    this.effectManager.updateEffect(event.effect, event);
                }
            }

            // Call each tick to manage effect lifetimes
            tickEffects() {
                this.effectManager.tick();
            }
        }

        // Note name helper
        const NOTE_NAMES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const midiToNoteName = (midi) => {
            const octave = Math.floor(midi / 12) - 1;
            const note = NOTE_NAMES[midi % 12];
            return `${note}${octave}`;
        };

        const isBlackKey = (midi) => {
            const note = midi % 12;
            return [1, 3, 6, 8, 10].includes(note);
        };

        // Get instrument display name
        const getInstrumentName = (wave) => {
            if (!wave) return 'sine';
            if (wave === 'drums') return 'drums';
            if (wave === 'sine') return 'sine';
            if (wave === 'sawtooth') return 'saw';
            if (wave === 'square') return 'square';
            if (wave === 'triangle') return 'tri';
            if (wave.startsWith('m:')) return `midi ${wave.split(':')[1]}`;
            if (wave.includes(':')) return wave.split(':')[0];
            return wave;
        };

        // Get color based on velocity (0-1)
        const getIntensityColor = (velocity, wave) => {
            const v = Math.min(1, Math.max(0, velocity));
            // Hue based on instrument type
            let hue = 0;
            if (wave === 'drums') hue = 0; // red
            else if (wave === 'sawtooth') hue = 30; // orange
            else if (wave === 'square') hue = 200; // blue
            else if (wave === 'triangle') hue = 280; // purple
            else if (wave && wave.startsWith('m:')) hue = 60; // yellow
            else hue = 120; // green for sine

            const saturation = 70 + v * 30;
            const lightness = 30 + v * 40;
            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        };

        // --- PIANO VISUALIZATION COMPONENT ---
        const PianoVisualization = ({ activeNotes }) => {
            // Show 3 octaves centered around middle C (C3 to B5 = MIDI 48-83)
            const startMidi = 36;
            const endMidi = 84;
            const keys = [];

            for (let midi = startMidi; midi < endMidi; midi++) {
                keys.push(midi);
            }

            const whiteKeys = keys.filter(m => !isBlackKey(m));
            const blackKeys = keys.filter(m => isBlackKey(m));

            // Find active note for a key
            const getActiveNote = (midi) => {
                return activeNotes.find(n => n.pitch === midi);
            };

            // Calculate black key position
            const getBlackKeyPosition = (midi) => {
                const note = midi % 12;
                const octave = Math.floor(midi / 12);
                const octaveStart = octave * 12;

                // White keys before this black key in the octave
                const whiteKeysBefore = [0, 2, 4, 5, 7, 9, 11].filter(n => n < note).length;
                const totalWhiteKeysBefore = (octave - Math.floor(startMidi / 12)) * 7 + whiteKeysBefore;

                // Offset based on which black key (between C#/D, D#/E, F#/G, G#/A, A#/B)
                const offsets = { 1: -0.35, 3: 0.35, 6: -0.35, 8: 0, 10: 0.35 };
                const offset = offsets[note] || 0;

                return (totalWhiteKeysBefore - 0.5 + offset) * (100 / whiteKeys.length);
            };

            return (
                <div style={{
                    flex: 1,
                    display: 'flex',
                    flexDirection: 'column',
                    background: '#fafafa',
                    padding: '40px 20px 20px 20px'
                }}>
                    {/* Active notes display */}
                    <div style={{
                        height: '80px',
                        display: 'flex',
                        flexWrap: 'wrap',
                        gap: '8px',
                        marginBottom: '20px',
                        alignContent: 'flex-start',
                        justifyContent: 'center'
                    }}>
                        {activeNotes.map((note, i) => (
                            <div key={i} style={{
                                padding: '4px 12px',
                                background: getIntensityColor(note.velocity, note.wave),
                                color: '#fff',
                                fontSize: '14px',
                                display: 'flex',
                                gap: '8px',
                                alignItems: 'center'
                            }}>
                                <span style={{ fontWeight: 'bold' }}>{midiToNoteName(note.pitch)}</span>
                                <span style={{ opacity: 0.8 }}>{getInstrumentName(note.wave)}</span>
                            </div>
                        ))}
                    </div>

                    {/* Piano keyboard */}
                    <div style={{
                        flex: 1,
                        display: 'flex',
                        justifyContent: 'center',
                        alignItems: 'flex-end',
                        paddingBottom: '40px'
                    }}>
                        <div style={{
                            position: 'relative',
                            height: '180px',
                            width: '100%',
                            maxWidth: '900px',
                            display: 'flex'
                        }}>
                            {/* White keys */}
                            {whiteKeys.map((midi, i) => {
                                const active = getActiveNote(midi);
                                return (
                                    <div key={midi} style={{
                                        flex: 1,
                                        height: '100%',
                                        background: active ? getIntensityColor(active.velocity, active.wave) : '#fff',
                                        border: '1px solid #1a1a1a',
                                        marginLeft: i === 0 ? 0 : '-1px',
                                        display: 'flex',
                                        flexDirection: 'column',
                                        justifyContent: 'flex-end',
                                        alignItems: 'center',
                                        paddingBottom: '8px',
                                        transition: 'background 0.05s'
                                    }}>
                                        {active && (
                                            <span style={{
                                                fontSize: '10px',
                                                color: '#fff',
                                                textShadow: '0 0 2px rgba(0,0,0,0.5)'
                                            }}>
                                                {getInstrumentName(active.wave)}
                                            </span>
                                        )}
                                        <span style={{
                                            fontSize: '9px',
                                            color: active ? '#fff' : '#999',
                                            marginTop: '2px'
                                        }}>
                                            {midiToNoteName(midi)}
                                        </span>
                                    </div>
                                );
                            })}

                            {/* Black keys */}
                            {blackKeys.map((midi) => {
                                const active = getActiveNote(midi);
                                const left = getBlackKeyPosition(midi);
                                return (
                                    <div key={midi} style={{
                                        position: 'absolute',
                                        left: `${left}%`,
                                        width: `${60 / whiteKeys.length}%`,
                                        height: '60%',
                                        background: active ? getIntensityColor(active.velocity, active.wave) : '#1a1a1a',
                                        border: '1px solid #000',
                                        zIndex: 1,
                                        display: 'flex',
                                        flexDirection: 'column',
                                        justifyContent: 'flex-end',
                                        alignItems: 'center',
                                        paddingBottom: '4px',
                                        transition: 'background 0.05s'
                                    }}>
                                        {active && (
                                            <span style={{
                                                fontSize: '8px',
                                                color: '#fff'
                                            }}>
                                                {getInstrumentName(active.wave)}
                                            </span>
                                        )}
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                </div>
            );
        };

        const DEFAULT_CODE = `// t: tick, s: seconds
// p: pitch, d: duration, v: volume, x: pan
// w: wave (sine, sawtooth, square, drums, m:1)

return (t, s) => {
  const notes = [];
  
  if (t % 4 === 0) notes.push({ p: 36, w: 'drums', v: 0.9 });
  if (t % 8 === 4) notes.push({ p: 38, w: 'drums', v: 0.8 });
  if (t % 2 === 0) notes.push({ p: 42, w: 'drums', v: 0.3 });

  if (t % 16 === 0) notes.push({ p: 36, d: 0.4, w: 'sawtooth', v: 0.6 });

  return notes;
};
`;

        const App = () => {
            const [isPlaying, setIsPlaying] = useState(false);
            const [code, setCode] = useState(DEFAULT_CODE);
            const [error, setError] = useState(null);
            const [bpm, setBpm] = useState(120);
            const [volume, setVolume] = useState(0.3);
            const [currentTick, setCurrentTick] = useState(0);
            const [isLiveLinked, setIsLiveLinked] = useState(false);
            const [midiOutputs, setMidiOutputs] = useState([]);
            const [selectedMidiOutput, setSelectedMidiOutput] = useState(null);
            const [activeNotes, setActiveNotes] = useState([]);
            const [sliders, setSliders] = useState([]);

            const engineRef = useRef(null);
            const userFuncRef = useRef(null);
            const workerRef = useRef(null);
            const nextNoteTimeRef = useRef(0);
            const tickCounterRef = useRef(0);
            const scheduleAheadTime = 0.1;

            useEffect(() => {
                const workerCode = `
                    let intervalId = null;
                    self.onmessage = function(e) {
                        if (e.data === 'start') {
                            intervalId = setInterval(() => self.postMessage('tick'), 25);
                        } else if (e.data === 'stop') {
                            clearInterval(intervalId);
                            intervalId = null;
                        }
                    };
                `;
                const blob = new Blob([workerCode], { type: 'application/javascript' });
                workerRef.current = new Worker(URL.createObjectURL(blob));
                return () => {
                    workerRef.current?.terminate();
                };
            }, []);

            useEffect(() => {
                let evtSource;
                const connectLiveLink = () => {
                    evtSource = new EventSource("http://localhost:8080/events");
                    evtSource.onmessage = (e) => {
                        try {
                            const data = JSON.parse(e.data);
                            setCode(data.code);
                            if (data.sliders) {
                                setSliders(data.sliders);
                            }
                            setIsLiveLinked(true);
                        } catch (err) { console.error(err); }
                    };
                    evtSource.onerror = () => {
                        setIsLiveLinked(false);
                        evtSource.close();
                        setTimeout(connectLiveLink, 2000);
                    };
                    evtSource.onopen = () => setIsLiveLinked(true);
                };
                connectLiveLink();
                return () => evtSource?.close();
            }, []);

            useEffect(() => {
                engineRef.current = new AudioEngine();
                engineRef.current.onMidiOutputsChange = () => {
                    setMidiOutputs([...engineRef.current.getMidiOutputs()]);
                    setSelectedMidiOutput(engineRef.current.getSelectedMidiOutput());
                };

                // Set up note event callback for visualization
                engineRef.current.onNoteEvent = (note) => {
                    setActiveNotes(prev => {
                        const now = Date.now();
                        const duration = (note.duration || 1.0) * 1000 + 100;
                        const newNote = { ...note, startTime: now, endTime: now + duration };
                        return [...prev.filter(n => n.endTime > now), newNote];
                    });
                };

                setTimeout(() => {
                    if (engineRef.current) {
                        setMidiOutputs([...engineRef.current.getMidiOutputs()]);
                        setSelectedMidiOutput(engineRef.current.getSelectedMidiOutput());
                    }
                }, 500);
                return () => engineRef.current?.ctx?.close();
            }, []);

            // Clean up expired notes periodically
            useEffect(() => {
                const interval = setInterval(() => {
                    const now = Date.now();
                    setActiveNotes(prev => prev.filter(n => n.endTime > now));
                }, 50);
                return () => clearInterval(interval);
            }, []);

            useEffect(() => engineRef.current?.setVolume(volume), [volume]);
            useEffect(() => engineRef.current?.setBpm(bpm), [bpm]);

            const handleSliderChange = async (name, value) => {
                // Optimistically update local state
                setSliders(prev => prev.map(s =>
                    s.name === name ? { ...s, value: parseFloat(value) } : s
                ));

                // Send update to server
                try {
                    await fetch('http://localhost:8080/update-slider', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name, value: parseFloat(value) })
                    });
                } catch (e) {
                    console.error('Failed to update slider:', e);
                }
            };

            useEffect(() => {
                try {
                    const createFunction = new Function(code);
                    const userFunc = createFunction();
                    if (typeof userFunc === 'function') {
                        userFuncRef.current = userFunc;
                        setError(null);
                    } else { throw new Error("Code must return a function."); }
                } catch (e) {
                    setError(e.message);
                    logErrorToServer(e.message, e.stack, 'user code compilation', null, null);
                }
            }, [code]);

            const scheduleNote = (tickNumber, time) => {
                if (userFuncRef.current && engineRef.current) {
                    try {
                        const events = userFuncRef.current(tickNumber, time);
                        const secondsPerTick = (60.0 / bpm) / 4.0;
                        if (Array.isArray(events)) {
                            // Separate effect events from note events
                            const effectEvents = events.filter(e => e.effect);
                            const noteEvents = events.filter(e => !e.effect);

                            // Process effect events first (so effects exist before notes try to send to them)
                            effectEvents.forEach(e => {
                                engineRef.current.processEffectEvent(e, bpm);
                            });

                            // Process note events
                            noteEvents.forEach(n => {
                                const midi = n.p || 60;
                                // All time parameters are in ticks, convert to seconds
                                const durTicks = n.d !== undefined ? n.d : 1.0;
                                const dur = durTicks * secondsPerTick;
                                const offsetTicks = n.o || 0;
                                const noteTime = time + (offsetTicks * secondsPerTick);
                                const opts = {
                                    vol: n.v,
                                    attack: n.a !== undefined ? n.a * secondsPerTick : undefined,
                                    decay: n.decay !== undefined ? n.decay * secondsPerTick : undefined,
                                    reverb: n.r,
                                    cutoff: n.c,
                                    wave: n.w || n.wave,
                                    fm: n.f || n.fm,
                                    ratio: n.ratio,
                                    pan: n.x,
                                    id: n.id,
                                    start: n.start,
                                    sends: n.sends  // New sends parameter
                                };
                                engineRef.current.playNote(midi, noteTime, dur, opts);
                            });
                        }

                        // Tick effect manager to handle lifetimes
                        engineRef.current.tickEffects();
                    } catch (e) {
                        console.error(e);
                        logErrorToServer(e.message, e.stack, 'user code execution', null, null);
                    }
                }
            };

            const scheduler = useCallback(() => {
                if (!engineRef.current) return;
                while (nextNoteTimeRef.current < engineRef.current.ctx.currentTime + scheduleAheadTime) {
                    scheduleNote(tickCounterRef.current, nextNoteTimeRef.current);
                    nextNoteTimeRef.current += (60.0 / bpm) / 4.0;
                    tickCounterRef.current++;
                }
                if (tickCounterRef.current % 4 === 0) {
                    setCurrentTick(tickCounterRef.current);
                }
            }, [bpm]);

            useEffect(() => {
                if (!workerRef.current) return;
                workerRef.current.onmessage = () => {
                    if (isPlaying) scheduler();
                };
            }, [isPlaying, scheduler]);

            const togglePlay = async () => {
                if (isPlaying) {
                    workerRef.current?.postMessage('stop');
                    setIsPlaying(false);
                    setActiveNotes([]);
                } else {
                    // Resume AudioContext first (required before Tone.start)
                    if (engineRef.current.ctx.state === 'suspended') {
                        await engineRef.current.ctx.resume();
                    }
                    // Start Tone.js (this also ensures AudioContext is running)
                    await Tone.start();
                    tickCounterRef.current = 0;
                    nextNoteTimeRef.current = engineRef.current.ctx.currentTime + 0.05;
                    setIsPlaying(true);
                    workerRef.current?.postMessage('start');
                }
            };

            return (
                <div style={{ display: 'flex', flexDirection: 'column', height: '100%' }}>
                    {/* Header */}
                    <div style={{
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'space-between',
                        padding: '16px 24px',
                        borderBottom: '1px solid #ddd'
                    }}>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '24px' }}>
                            <span style={{ fontSize: '18px', letterSpacing: '0.1em' }}>livecoding</span>

                            <button
                                onClick={togglePlay}
                                style={{
                                    padding: '8px 20px',
                                    background: isPlaying ? '#1a1a1a' : '#fff',
                                    color: isPlaying ? '#fff' : '#1a1a1a',
                                    border: '1px solid #1a1a1a',
                                    cursor: 'pointer',
                                    fontSize: '14px'
                                }}
                            >
                                {isPlaying ? "stop" : "play"}
                            </button>

                            {isLiveLinked && (
                                <span style={{ fontSize: '12px', color: '#666' }}>linked</span>
                            )}

                            <div style={{ display: 'flex', flexDirection: 'column', gap: '2px', width: '100px' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '11px', color: '#666' }}>
                                    <span>bpm</span><span>{bpm}</span>
                                </div>
                                <input type="range" min="60" max="200" value={bpm} onChange={(e) => setBpm(Number(e.target.value))} />
                            </div>

                            <div style={{ display: 'flex', flexDirection: 'column', gap: '2px', width: '100px' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '11px', color: '#666' }}>
                                    <span>vol</span><span>{Math.round(volume * 100)}%</span>
                                </div>
                                <input type="range" min="0" max="1" step="0.01" value={volume} onChange={(e) => setVolume(Number(e.target.value))} />
                            </div>

                            {midiOutputs.length > 0 && (
                                <div style={{ display: 'flex', flexDirection: 'column', gap: '2px' }}>
                                    <span style={{ fontSize: '11px', color: '#666' }}>midi</span>
                                    <select
                                        value={selectedMidiOutput || ''}
                                        onChange={(e) => {
                                            setSelectedMidiOutput(e.target.value);
                                            engineRef.current?.setMidiOutput(e.target.value);
                                        }}
                                        style={{
                                            background: '#fff',
                                            border: '1px solid #ccc',
                                            padding: '4px 8px',
                                            fontSize: '12px'
                                        }}
                                    >
                                        {midiOutputs.map(o => (
                                            <option key={o.id} value={o.id}>{o.name}</option>
                                        ))}
                                    </select>
                                </div>
                            )}
                        </div>

                        <div style={{ display: 'flex', alignItems: 'center', gap: '16px' }}>
                            {error && (
                                <span style={{ fontSize: '12px', color: '#c00' }}>{error}</span>
                            )}
                            <span style={{ fontSize: '12px', color: '#999' }}>tick {currentTick}</span>
                        </div>
                    </div>

                    {/* Centered Sliders */}
                    {sliders.length > 0 && (
                        <div style={{
                            display: 'flex',
                            justifyContent: 'center',
                            alignItems: 'center',
                            padding: '40px 20px',
                            gap: '40px',
                            flexWrap: 'wrap'
                        }}>
                            {sliders.map(slider => (
                                <div key={slider.name} style={{
                                    display: 'flex',
                                    flexDirection: 'column',
                                    gap: '8px',
                                    width: '200px',
                                    alignItems: 'center'
                                }}>
                                    <div style={{
                                        display: 'flex',
                                        justifyContent: 'space-between',
                                        fontSize: '14px',
                                        color: '#1a1a1a',
                                        width: '100%'
                                    }}>
                                        <span style={{ fontWeight: 'bold' }}>{slider.name}</span>
                                        <span>{Number(slider.value) % 1 === 0 ? slider.value.toFixed(0) : slider.value.toFixed(2)}</span>
                                    </div>
                                    <input
                                        type="range"
                                        min={slider.min}
                                        max={slider.max}
                                        value={slider.value}
                                        onChange={(e) => handleSliderChange(slider.name, e.target.value)}
                                        step={(slider.max - slider.min) > 10 ? 0.1 : 0.01}
                                        style={{ width: '100%' }}
                                    />
                                    <div style={{
                                        display: 'flex',
                                        justifyContent: 'space-between',
                                        fontSize: '10px',
                                        color: '#999',
                                        width: '100%'
                                    }}>
                                        <span>{slider.min}</span>
                                        <span>{slider.max}</span>
                                    </div>
                                </div>
                            ))}
                        </div>
                    )}

                    {/* Piano visualization */}
                    <PianoVisualization activeNotes={activeNotes} />
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>